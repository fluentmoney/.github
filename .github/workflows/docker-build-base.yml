## Name of the workflow
name: Docker Build & Push to ACR


## The variables needed to run the workflow
on:
  workflow_call:
    inputs:
      ## Name of the container/image
      container:
        required: true
        type: string
      ## Path to the Docker build context
      buildcontextpath:
        required: true
        type: string
      ## Path to the .NET project file
      projectfilepath:
        required: true
        type: string
      ## Path to the Dockerfile
      dockerfilepath:
        required: true
        type: string
      ## Whether to fail on test failures
      stricttestfailures:
        required: false
        type: boolean
        default: false
      ## .NET SDK version to use
      dotnetcoreversion:
        required: false
        type: string
        default: '7.0.x'
      ## Container registry service connection
      containerregistry:
        required: false
        type: string
        default: 'service-connection-fluent-acr'
      ## Force Docker build regardless of branch
      forcedockerbuild:
        required: false
        type: boolean
        default: false
    secrets:
      ## NuGet authentication token
      nugetauthtoken:
        required: true
      ## fmgConfig connection string
      fmgConfigConnectionString:
        required: true
      ## Azure Container Registry URL
      acrRegistryUrl:
        required: true
      ## Azure Container Registry Username
      acrUsername:
        required: true
      ## Azure Container Registry Password
      acrPassword:
        required: true

jobs:
  ## Jobs the workflow runs
  unit-tests:
    uses: ./.github/workflows/dotnet-unit-tests.yml
    with:
      dotnetcoreversion: ${{ inputs.dotnetcoreversion }}
      projectfilepath: ${{ inputs.projectfilepath }}
      stricttestfailures: ${{ inputs.stricttestfailures }}
    secrets:
      nugetauthtoken: ${{ secrets.nugetauthtoken }}
      fmgConfigConnectionString: ${{ secrets.fmgConfigConnectionString }}

  build-and-push:
    runs-on: ubuntu-latest
    needs: unit-tests
    ## Only build if forced or tests succeeded and on master branch
    if: ${{ inputs.forcedockerbuild || (success() && github.ref == 'refs/heads/main') }}
    steps:

      ## Step 1: Generate a build number based on the current date
      - name: Get date
        id: date
        run: echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT

      ## Step 2: Restore the build counter from cache or initialize it
      - name: Restore build counter
        id: cache
        uses: actions/cache@v4
        with:
          path: .build_counter
          key: build-counter-${{ steps.date.outputs.date }}
          restore-keys: |
            build-counter-${{ steps.date.outputs.date }}

      ## Step 3: Increment the build counter
      - name: Increment counter
        id: counter
        run: |
          if [ -f .build_counter ]; then
            count=$(cat .build_counter)
          else
            count=0
          fi
          count=$((count + 1))
          echo $count > .build_counter
          echo "RUN_NUM=$count" >> $GITHUB_ENV
          echo "run_num=$count" >> $GITHUB_OUTPUT

      ## Step 4: Save the updated build counter to cache
      - name: Save counter
        uses: actions/cache@v4
        with:
          path: .build_counter
          key: build-counter-${{ steps.date.outputs.date }}-${{ steps.counter.outputs.run_num }}
          restore-keys: |
            build-counter-${{ steps.date.outputs.date }}
          save-always: true

      ## Step 5: Show the generated tag for debugging
      - name: Show generated tag
        run: |
          echo "Docker tag: ${{ steps.date.outputs.date }}.${{ steps.counter.outputs.run_num }}"

      ## Step 6: Checkout the repository code (with credentials)
      - uses: actions/checkout@v4
        with:
          persist-credentials: true

      ## Step 7: Add the NuGet source for the project
      - name: Add NuGet source
        run: dotnet nuget add source https://pkgs.dev.azure.com/FluentMoneyGroup/fmg-myfluent/_packaging/fluent/nuget/v3/index.json --name fluent --username anything --password ${{ secrets.nugetauthtoken }} --store-password-in-clear-text

      ## Step 8: Restore the project dependencies
      - name: Restore dependencies
        run: dotnet restore ${{ inputs.buildcontextpath }}

      ## Step 9: Login to Azure Container Registry
      - name: Login to Azure Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ secrets.acrRegistryUrl }}
          username: ${{ secrets.acrUsername }}
          password: ${{ secrets.acrPassword }}
      
      ## Step 10: Build the Docker image
      - name: Build and Push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ inputs.buildcontextpath }}
          file: ${{ inputs.dockerfilepath }}
          push: true
          tags: |
            ${{ secrets.acrRegistryUrl }}/${{ steps.date.outputs.date }}.${{ steps.counter.outputs.run_num }}.githubtest
            ${{ secrets.acrRegistryUrl }}/latest
          build-args: |
            FEED_ACCESSTOKEN=${{ secrets.nugetauthtoken }}

      ## Step 11: Tag the git commit for traceability
      - name: Git Tag
        run: |
          git tag builds/${{ github.workflow }}/${{ steps.date.outputs.date }}.${{ steps.counter.outputs.run_num }}.githubtest
          git push origin builds/${{ github.workflow }}/${{ steps.date.outputs.date }}.${{ steps.counter.outputs.run_num }}.githubtest
        working-directory: ${{ github.workspace }}

  push_git_tag:
    runs-on: ubuntu-latest
    needs: [unit-tests, build-and-push]
    ## Only run if everything succeeded and on master branch
    if: ${{ success() && github.ref == 'refs/heads/main' }}
    steps:

      ## Step 1: Generate a build number based on the current date
      - name: Get date
        id: date
        run: echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT

      ## Step 2: Restore the build counter from cache or initialize it
      - name: Restore build counter
        id: cache
        uses: actions/cache@v4
        with:
          path: .build_counter
          key: build-counter-${{ steps.date.outputs.date }}
          restore-keys: |
            build-counter-${{ steps.date.outputs.date }}

      ## Step 3: Increment the build counter
      - name: Increment counter
        id: counter
        run: |
          if [ -f .build_counter ]; then
            count=$(cat .build_counter)
          else
            count=0
          fi
          count=$((count + 1))
          echo $count > .build_counter
          echo "RUN_NUM=$count" >> $GITHUB_ENV
          echo "run_num=$count" >> $GITHUB_OUTPUT

      ## Step 4: Save the updated build counter to cache
      - name: Save counter
        uses: actions/cache@v4
        with:
          path: .build_counter
          key: build-counter-${{ steps.date.outputs.date }}-${{ steps.counter.outputs.run_num }}
          restore-keys: |
            build-counter-${{ steps.date.outputs.date }}

      ## Step 5: Show the generated tag for debugging
      - name: Show generated tag
        run: |
          echo "Docker tag: ${{ steps.date.outputs.date }}.${{ steps.counter.outputs.run_num }}"

      ## Step 1: Set a KeyVault secret with the build number for release tracking
      - name: Set KeyVault Secret
        uses: azure/CLI@v2
        with:
          azcliversion: latest
          inlineScript: |
            echo "Container: ${{ inputs.container }}"
            echo "Build.BuildNumber: ${{ steps.date.outputs.date }}.${{ steps.counter.outputs.run_num }}.githubtest"
            echo "Build.SourceBranch: ${{ github.ref }}"
            echo "Build.DefinitionName: ${{ github.workflow }}"
            az keyvault secret set --vault-name ReleaseVault --name "${{ inputs.container }}" --value ${{ steps.date.outputs.date }}.${{ steps.counter.outputs.run_num }}.githubtest
